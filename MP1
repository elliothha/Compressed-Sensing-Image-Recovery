import math
import random
from itertools import product

import numpy
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from numpy import double
from PIL import Image

import warnings

warnings.filterwarnings("ignore", category=UserWarning)

random.seed(a=None, version=2)
# value for kxk blocks
k = 8


# reads and returns the argument image
def imgRead(file):
    imgIn = Image.open(file).convert('L')
    return double(imgIn)


# plots the argument image
def imgShow(imgOut):
    plt.imshow(imgOut, cmap=cm.gray)
    # plt.imshow(imgOut)
    plt.show()


# k^2 - S corrupted pixels given S = sensed pixels
def corruptKxKBlock(imgIn, S):
    corruptPixels = random.sample([[x, y]
                                   for x in range(0, imgIn.shape[0])
                                   for y in range(0, imgIn.shape[1])],
                                  (k * k - S))
    for pixel in corruptPixels:
        imgIn[pixel[0], pixel[1]] = np.nan

    return imgIn


# returns KxK block with topLeftX and topLeftY as the top-left corner pixel
# X = col number, Y = row number !!!
def getKxKBlock(imgIn, topLeftX, topLeftY):
    # imgIn.shape returns a [width, height] array of the image dimensions
    # if statement ensures we have enough space to make the KxK block
    if topLeftX + k <= imgIn.shape[0] and topLeftY <= imgIn.shape[1]:
        imgIn = np.array(imgIn)
        imgOut = []
        for rowNum in range(topLeftY, (topLeftY + k)):
            # arr = each individual row of the KxK block going top to bottom
            arr = imgIn[rowNum, topLeftX:(topLeftX + k)]
            imgOut.append(arr.tolist())
        imgOut = np.asarray(imgOut)
        return imgOut
    else:
        raise Exception('Invalid Dimensions!')


def generateBasisVectorMatrix():
    basisVectorMatrix = []
    for u in range(1, k + 1):

        for v in range(1, k + 1):

            # there will be K^2 basisChips altogether
            # one basisChip for every (u, v) pair
            # u goes 1 to K, and for each u, v goes 1 to K for K^2 total basisChips
            # each basisChip is a KxK matrix of DCT values for a (x, y) pair
            basisChip = []
            # each x iteration from 1 to K produces K rows
            for x in range(1, k + 1):

                # for each x, we get every pairing of the y values
                # for each resulting (x, y) pair, we calculate a DCT value
                # each basisChipRow is a row vector with K elements
                # each element is DCT value for [(X=x and y={1,...,K})]
                basisChipRow = []
                for y in range(1, k + 1):

                    # calculate DCT
                    alphaU = np.sqrt((2 / k))
                    if u == 1:
                        alphaU = np.sqrt((1 / k))
                    betaV = np.sqrt((2 / k))
                    if v == 1:
                        betaV = np.sqrt((1 / k))

                    valXU = ((2 * x - 1) * (u - 1) / (2 * k))
                    valYV = ((2 * y - 1) * (v - 1) / (2 * k))

                    cosXU = np.cos(np.pi * valXU)
                    cosYV = np.cos(np.pi * valYV)

                    element = alphaU * betaV * cosXU * cosYV
                    basisChipRow.append(element)

                # now that each row is full, we want to stack rows on top of each other
                # this creates a KxK matrix for the basisChip
                basisChip.append(basisChipRow)

            # now that we have a KxK matrix for the basisChip, need to transpose it
            # this is because x is technically columns and y rows
            # basically for each value on the horizontal axis, we want
            # the list of values to stretch down along the vertical axis
            basisChip = np.asarray(basisChip)
            np.transpose(basisChip)

            # need to rasterize each basisChip now, and then we can add to basisVectorMatrix
            # turns each KxK basisChip matrix into a single column with K^2 values
            # np.hsplit turns basisChip into an array of k separate columns
            basisChipCols = np.hsplit(basisChip, k)
            # vertically stacking all the columns on top of each other to "rasterize"
            rasterizedBasisChip = np.vstack(basisChipCols)

            # appending each column of K^2 values horizontally to basisVectorMatrix
            basisVectorMatrix.append(rasterizedBasisChip)

    # our problem here is that basisVectorMatrix is a 3D array:
    # it is an K^2 size array of K^2x1 arrays, therefore K^2xK^2x1
    # we want it to be simply K^2xK^2
    # for a 3D array of shape (x,y,z), we can turn it into (x*y,z) by reshape(-1,z)
    basisVectorMatrix = np.asarray(basisVectorMatrix)
    # we want the 1 dimension to be one of x and y so that we have (K^2 * 1 by K^2)
    # transposes basisVectorMatrix to be 1xK^2xK^2
    basisVectorMatrix = np.transpose(basisVectorMatrix, (2, 0, 1))
    basisVectorMatrix = basisVectorMatrix.reshape(-1, (k * k))
    # ended up having to transpose one last time
    basisVectorMatrix = np.transpose(basisVectorMatrix)

    return basisVectorMatrix


def imageReconstruction(image, S):
    B = generateBasisVectorMatrix()
    # the image we pass will be the corrupted KxK block for now
    C = image
    # S = number of sensed pixels
    S = S
    # column vector of the remaining sensed pixels
    # sensed pixels = sampled pixels
    # remove NaN values from C and then turn remaining values into a column vector
    # D = C[~np.isnan(C)]
    # D = D.reshape(-1, 1)

    # Consider a large range of l: 1e-6 â†’ 1e+6, with a few values per decade [logspace]
    # look up logspace doc, same values every program compile :D

    # lambdaRange = np.logspace(-6, 6, num=40, base=10.0, endpoint=True)
    lambdaRange = [1e6]

    for regularizationParam in lambdaRange:
        # total error for each separate regularization parameter
        totalError = 0
        for M in range(0, 1):
            # TODO: Partition the S sensed pixels in the block (the training set) into
            # TODO: m=floor(S/6) testing pixels and (S-m) training pixels
            # randomly draw m pixels from the non-NaN values to form the test set
            m = np.floor(S / 6)
            allKxKCoords = list(product(range(k), range(k)))
            allKxKCoords = np.asarray(allKxKCoords)
            testingSetCoords = []
            while len(testingSetCoords) < m:
                randomCoordIndex = np.random.choice(len(allKxKCoords), size=1)
                randomCoord = [allKxKCoords[randomCoordIndex][0][0], allKxKCoords[randomCoordIndex][0][1]]
                if randomCoord not in testingSetCoords and not math.isnan(C[randomCoord[0], randomCoord[1]]):
                    testingSetCoords.append(randomCoord)
            # use the remaining (S-m) pixels to form the training set
            trainingSetCoords = []
            for row in range(k):
                for col in range(k):
                    if [row, col] not in testingSetCoords and not math.isnan(C[row][col]):
                        trainingSetCoords.append([row, col])

            # TODO: Determine the basis vector (DCT) coefficients for the (S-m) pixels in the training set
            # If the trainingSet is the column vector 'D',
            # then we need the original (x,y) coordinates of each pixel in the trainingSet to get 'A'
            trainingSet = []
            for coordinate in trainingSetCoords:
                trainingSet.append(C[coordinate[0], coordinate[1]])
            trainingSet = np.asarray(trainingSet).reshape(-1, 1)
            # if trainingBasisMatrix is the matrix 'A',
            # A = rows from B corresponding to (x,y) locations of sensed pixels
            A = []
            for coordinate in trainingSetCoords:
                basisRowNumber = 8*coordinate[0] + coordinate[1]
                basisRow = np.asarray(B[basisRowNumber, :])
                A.append(basisRow)
            A = np.asarray(A)
            # Now we can calculate the DCT coefficient for the training data



def main():
    S = 50

    originalImage = imgRead('C:/Users/ellio/PycharmProjects/pythonProject/fishing_boat.bmp')
    # imgShow(originalImage)
    # print("Original Image")
    # print(originalImage)
    # print(originalImage.shape)

    kxkBlock = getKxKBlock(originalImage, 100, 150)
    # imgShow(kxkBlock)
    # print("KxK Block")
    # print(kxkBlock)

    corruptedkxkBlock = corruptKxKBlock(kxkBlock, S)
    # imgShow(corruptedkxkBlock)
    # print("Corrupt KxK Block")
    # print(corruptedkxkBlock)
    # print()

    # TODO: Visualization for K = 8, K = 16 basis vectors
    B = generateBasisVectorMatrix()
    # print(B)
    # imgShow(generateBasisVectorMatrix())

    # TODO: MSE as a function of regularization parameter with S = 50
    # TODO: LASSO reconstruction using best regularization parameter value
    imageReconstruction(corruptedkxkBlock, S)


main()
