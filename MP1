import math
import random

import numpy
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from numpy import double
from PIL import Image

import warnings

warnings.filterwarnings("ignore", category=UserWarning)

random.seed(a=None, version=2)
# value for kxk blocks
k = 8


# reads and returns the argument image
def imgRead(file):
    imgIn = Image.open(file).convert('L')
    return double(imgIn)


# plots the argument image
def imgShow(imgOut):
    plt.imshow(imgOut, cmap=cm.gray)
    # plt.imshow(imgOut)
    plt.show()


# k^2 - S corrupted pixels given S = sensed pixels
def corruptKxKBlock(imgIn, S):
    corruptPixels = random.sample([[x, y]
                                   for x in range(0, imgIn.shape[0])
                                   for y in range(0, imgIn.shape[1])],
                                  (k * k - S))
    for pixel in corruptPixels:
        imgIn[pixel[0], pixel[1]] = np.nan

    return imgIn


# returns KxK block with topLeftX and topLeftY as the top-left corner pixel
# X = col number, Y = row number !!!
def getKxKBlock(imgIn, topLeftX, topLeftY):
    # imgIn.shape returns a [width, height] array of the image dimensions
    # if statement ensures we have enough space to make the KxK block
    if topLeftX + k <= imgIn.shape[0] and topLeftY <= imgIn.shape[1]:
        imgIn = np.array(imgIn)
        imgOut = []
        for rowNum in range(topLeftY, (topLeftY + k)):
            # arr = each individual row of the KxK block going top to bottom
            arr = imgIn[rowNum, topLeftX:(topLeftX + k)]
            imgOut.append(arr.tolist())
        imgOut = np.asarray(imgOut)
        return imgOut
    else:
        raise Exception('Invalid Dimensions!')


def generateBasisVectorMatrix():
    basisVectorMatrix = []
    for u in range(1, k + 1):

        for v in range(1, k + 1):

            # there will be K^2 basisChips altogether
            # one basisChip for every (u, v) pair
            # u goes 1 to K, and for each u, v goes 1 to K for K^2 total basisChips
            # each basisChip is a KxK matrix of DCT values for a (x, y) pair
            basisChip = []
            # each x iteration from 1 to K produces K rows
            for x in range(1, k + 1):

                # for each x, we get every pairing of the y values
                # for each resulting (x, y) pair, we calculate a DCT value
                # each basisChipRow is a row vector with K elements
                # each element is DCT value for [(X=x and y={1,...,K})]
                basisChipRow = []
                for y in range(1, k + 1):

                    # calculate DCT
                    alphaU = np.sqrt((2 / k))
                    if u == 1:
                        alphaU = np.sqrt((1 / k))
                    betaV = np.sqrt((2 / k))
                    if v == 1:
                        betaV = np.sqrt((1 / k))

                    valXU = ((2 * x - 1) * (u - 1) / (2 * k))
                    valYV = ((2 * y - 1) * (v - 1) / (2 * k))

                    cosXU = np.cos(np.pi * valXU)
                    cosYV = np.cos(np.pi * valYV)

                    element = alphaU * betaV * cosXU * cosYV
                    basisChipRow.append(element)

                # now that each row is full, we want to stack rows on top of each other
                # this creates a KxK matrix for the basisChip
                basisChip.append(basisChipRow)

            # now that we have a KxK matrix for the basisChip, need to transpose it
            # this is because x is technically columns and y rows
            # basically for each value on the horizontal axis, we want
            # the list of values to stretch down along the vertical axis
            basisChip = np.asarray(basisChip)
            np.transpose(basisChip)

            # need to rasterize each basisChip now, and then we can add to basisVectorMatrix
            # turns each KxK basisChip matrix into a single column with K^2 values
            # np.hsplit turns basisChip into an array of k separate columns
            basisChipCols = np.hsplit(basisChip, k)
            # vertically stacking all the columns on top of each other to "rasterize"
            rasterizedBasisChip = np.vstack(basisChipCols)

            # appending each column of K^2 values horizontally to basisVectorMatrix
            basisVectorMatrix.append(rasterizedBasisChip)


    # our problem here is that basisVectorMatrix is a 3D array:
    # it is an K^2 size array of K^2x1 arrays, therefore K^2xK^2x1
    # we want it to be simply K^2xK^2
    # for a 3D array of shape (x,y,z), we can turn it into (x*y,z) by reshape(-1,z)
    basisVectorMatrix = np.asarray(basisVectorMatrix)
    # we want the 1 dimension to be one of x and y so that we have (K^2 * 1 by K^2)
    # transposes basisVectorMatrix to be 1xK^2xK^2
    basisVectorMatrix = np.transpose(basisVectorMatrix, (2, 0, 1))
    basisVectorMatrix = basisVectorMatrix.reshape(-1, (k*k))
    # ended up having to transpose one last time
    basisVectorMatrix = np.transpose(basisVectorMatrix)

    return basisVectorMatrix


def imageReconstruction(image, S):
    # the image we pass will be the corrupted KxK block for now
    C = image
    print(C)
    # S = number of sensed pixels
    S = S
    # column vector of the remaining sensed pixels
    # sensed pixels = sampled pixels
    # remove NaN values from C and then turn remaining values into a column vector
    D = C[~np.isnan(C)]
    D = D.reshape(-1, 1)

    # Consider a large range of l: 1e-6 â†’ 1e+6, with a few values per decade [logspace]
    # look up logspace doc, same values every program compile :D

    # lambdaRange = np.logspace(-6, 6, num=40, base=10.0, endpoint=True)
    lambdaRange = [1e6]

    for regularizationParam in lambdaRange:
        # total error for each separate regularization parameter
        totalError = 0
        for M in range(0, 1):
            m = np.floor(S/6)

            # TODO: Partition the S sensed pixels in the block (the training set) into
            # TODO: m=floor(S/6) testing pixels and (S-m) training pixels
            # Logic for determining trainingSet and testingSet:
            # 1. set trainingSet as the values of D as a row vector, we will delete the m pixels to get our S-m set
            # 2. generate a list of the indices (our 'm' pixels) that we will be
            #   (a). adding the value of trainingSet[index] to testingSet
            #   (b). removing trainingSet[index]
            # 3. We sort trainingSetIndices greatest to least after the first loop to avoid arrayOutOfBounds errors
            elementNum = len(D) * len(D[0])
            trainingSet = np.reshape(D, elementNum)
            trainingSetIndices = np.random.choice(elementNum, size=int(m), replace=False)
            testingSet = []
            for index in trainingSetIndices:
                testingSet.append(trainingSet[index])
            trainingSetIndices[::-1].sort()
            for index in trainingSetIndices:
                trainingSet = np.delete(trainingSet, index)
            testingSet = np.asarray(testingSet)

            # TODO: Determine the basis vector (DCT) coefficients for the (S-m) pixels in the training set
            # If the trainingSet is the column vector 'D', 
            # then we need the original (x,y) coordinates of each pixel in the trainingSet to get 'A'



def main():
    S = 50

    originalImage = imgRead('C:/Users/ellio/PycharmProjects/pythonProject/fishing_boat.bmp')
    # imgShow(originalImage)
    # print("Original Image")
    # print(originalImage)
    # print(originalImage.shape)

    kxkBlock = getKxKBlock(originalImage, 100, 150)
    # imgShow(kxkBlock)
    # print("KxK Block")
    # print(kxkBlock)

    corruptedkxkBlock = corruptKxKBlock(kxkBlock, S)
    # imgShow(corruptedkxkBlock)
    # print("Corrupt KxK Block")
    # print(corruptedkxkBlock)
    # print()


    # TODO: Visualization for K = 8, K = 16 basis vectors
    # imgShow(generateBasisVectorMatrix())

    # TODO: MSE as a function of regularization parameter with S = 50
    # TODO: LASSO reconstruction using best regularization parameter value
    imageReconstruction(corruptedkxkBlock, S)


main()
